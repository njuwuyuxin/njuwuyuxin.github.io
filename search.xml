<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[从零搭建教务抢课系统（一）]]></title>
    <url>%2F2019%2F12%2F26%2F%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%95%99%E5%8A%A1%E6%8A%A2%E8%AF%BE%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[目录（一）核心功能：模拟登陆（二）获取教务网选课列表（三）循环选课（四）断线重连 Github链接： https://github.com/njuwuyuxin/CourseGrabber一、前言响应群里学弟学妹号召，心血来潮想做一个南大教务网的抢课系统。在仔细研究了一下教务平台的js代码之后，发现几乎没有什么防护措施，于是便开始着手尝试起来。 抢课系统的主要思路无非就是以下几步： 模拟教务平台的网页登录，获取session 登入平台后拉取各个课程列表 找到对应课程编号，构造选课请求体，循环发送 为了方便调试检验，还使用了wireshark进行简单抓包（可省略），有需要的小伙伴可以自行下载 二、模拟登陆首先进入教务网登陆界面，尝试一次普通登录可以发现登录的请求体主要由四个表项组成，returnUrl暂无具体含义，默认为null，其余均为用户提交表单。这里唯一比较棘手的一点是验证码的获取。 验证码获取南大教务平台的验证码是通过向后端jsp请求获得。因此在代码里我们同样用模拟浏览器的方式进行请求。 12345678910#首先创建一个sessionsession &#x3D; requests.session()#取得验证码图片now_time &#x3D; str(int(time.time()))pic_url &#x3D; host + &#39;ValidateCode.jsp&#39;pic &#x3D; session.get(pic_url).contentfilename &#x3D; &#39;&#39; + now_time + &#39;.jpg&#39; with open(filename, &#39;wb&#39;) as f: f.write(pic) 这里首先创建了一个session，确保获取验证码和登录请求为同一个session，向对应jsp请求，将请求获得的图片保存在本地。之后尝试使用了ocr进行验证码的自动识别，由于验证码干扰严重，OCR无法识别，因而放弃 123456#尝试使用OCR自动识别验证码，但是由于验证码干扰较多，不能正确识别，因此采用手动输入方式# img &#x3D; Image.open(filename)# img&#x3D;img.convert(&#39;L&#39;)# vcode &#x3D; pytesseract.image_to_string(img) # 使用ocr技术将图片中的验证码读取出来# time.sleep(0.3) # print(vcode) OCR无法自动识别，那么我们只能采用手动输入验证码的方式，每次登陆时根据获取到本地的验证码进行输入，登陆后自动删除临时图片。同时发现验证码大约有100秒有效时间，因此需及时输入，否则验证码过期需要重新获取 登录请求体构造之后我们就可以构造登录请求体，这里为了方便测试，可以选择性读取存储用户信息的配置文件，也可以控制台进行输入 12345678910111213141516171819login_data&#x3D;&#123;&#125;files &#x3D; os.listdir()if &quot;user.cfg&quot; in files: with open(&quot;user.cfg&quot;,&#39;r&#39;) as f: for line in f: items &#x3D; line.split(&quot;:&quot;) items[1]&#x3D;items[1].replace(&#39;\n&#39;,&#39;&#39;).replace(&#39;\r&#39;,&#39;&#39;) login_data[items[0]]&#x3D;items[1]else: print(&quot;请输入用户名&quot;) login_data[&#39;userName&#39;]&#x3D;input() print(&quot;请输入密码&quot;) login_data[&#39;password&#39;]&#x3D;input() login_data[&#39;retrunURL&#39;]&#x3D;&quot;null&quot;print(&quot;请输入验证码(Please enter the ValidateCode)&quot;)vcode&#x3D;input()os.remove(filename) #输入完验证码后自动删除本地图片 login_data[&#39;ValidateCode&#39;]&#x3D;vcode 发送登录请求构造好请求体之后，我们将对应post请求发送到后端端口即可，这里由于无论登陆成功或失败，都会返回200表示请求成功，并不代表登陆成功。而返回的response分别对应错误页面的html和成功页面的html，因此这里简单对response长度进行判断来判断是否登陆成功。 12345678#发送登录请求response &#x3D; session.post(host+&quot;login.do&quot;,login_data)if response.content.__len__() &gt; 1100: print(&quot;登陆成功!&quot;) return Trueelse: print(&quot;登录失败，请检查账号密码及验证码&quot;) return False 输入完用户信息后，成功登录后，wireshark抓包可以看到对应数据包打印请求体后，可以发现正是教务平台登陆成功后的主页的html，至此，抢课系统的核心登录部分已经完成。之后可以解析HTML获得相关信息（类似爬虫），或发送选课请求等均可。]]></content>
      <categories>
        <category>简单尝试</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>抢课系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs+express框架搭建简单后端服务]]></title>
    <url>%2F2019%2F06%2F07%2Fnodejs-express%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%E7%AE%80%E5%8D%95%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[Node安装由于后端服务通常部署在linux服务器上，因此简单说下linux环境下node的安装。 可以选择去官网下载编译好的二进制文件，软链接到环境目录下。也可以使用apt工具直接安装 1sudo apt-get install node Express框架express是一个功能十分强大的框架，可以同时兼顾前后端开发。但由于这次只是想用express实现后端服务，因此不需要express提供的前端开发模板相关功能。所以只是在项目中引入了express模块 1npm install express 之后就可以在项目中通过require的方式使用express模块 Express的使用首先需要在需要的文件中引入express模块 12var express &#x3D; require(&#39;epxress&#39;);var app &#x3D; express(); 之后需要创建一个http服务器，但是由于我的网站而言，需要提供https服务，因此创建了一个https服务器 1234var httpsServer &#x3D; https.createServer(options, app);httpsServer.listen(parseInt(config.port),function()&#123; console.log(&quot;Https server is running on: https:&#x2F;&#x2F;localhost:&quot;+config.port);&#125;); 创建https服务器时需要一个额外参数option，用来指定服务器所需证书的路径，只有证书有效，才能创建https服务。至于端口号，可以自行指定，由于网站前端运行在默认443端口，因此选择不冲突的端口即可。 创建好服务器之后，我们就可以用app实例去监听对应的请求。express框架为我们实现了路由功能，因此可以很方便的通过路径来区分各种请求。 123456789app.get(&#39;&#x2F;api&#x2F;activities&#39;,newsApi.getActivities);app.get(&#39;&#x2F;api&#x2F;activityCards&#39;,newsApi.getActivityCards);app.post(&#39;&#x2F;api&#x2F;reviewCards&#39;,newsApi.getReviewCards);function getActivities(req, res)&#123; ... ... res.send(&#39;...&#39;)&#125; 通过调用app的get和post方法，我们可以处理get和post请求，第一个参数即为路由的路径，第二个参数为一个函数闭包，用来处理对应的请求。该闭包会接受两个参数req和res，分别对应请求体和返回的内容]]></content>
      <categories>
        <category>后端学习</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>express</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git快速上手]]></title>
    <url>%2F2019%2F04%2F18%2Fgit%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%2F</url>
    <content type="text"><![CDATA[前言git作为一个先进的版本管理工具，已经被广泛应用在大量项目中。近来发现了一个非常不错的git学习网站，虽然比较基础，但是可视化的界面能够帮助新人快速理解git每项指令的功能，同时也可以一定程度上的查漏补缺。网站地址：https://learngitbranching.js.org/而本文也记录了一些常用的git指令和使用技巧 常用git指令新建仓库在当前目录初始化一个git仓库git init新建一个目录，初始化一个git仓库git init [projectName]用于从远程仓库进行克隆，一般可以选择通过https或者ssh方式git clone [url] 配置对于刚安装git的新人，一般需要配置邮箱和用户名，建议使用全局方式配置git conifg [--global] user.name &quot;[username]&quot;git conifg [--global] user.email &quot;[email]&quot;可以查看当前的git配置git config --list可以直接编辑git配置文件，之前通过命令行配置的在此也可以看到git config -e [--global] 增加、删除文件这里需要简单介绍一下git中工作区和暂存区的概念 工作区可以简单理解为你在当前仓库的种种改动，git可以检测到但是并未将之准备为下次提交的内容。需要用户将之添加到暂存区。 暂存区可以简单理解为，下次执行提交中会被提交上去的文件。 整个工作流为： 你修改了某个文件 -&gt; 该文件变为工作区文件 -&gt; 你添加该文件进入暂存区 -&gt; 提交暂存区文件，该文件被提交 添加指定文件到暂存区git add [file1] [file2] ...添加指定目录到暂存区（包含该目录下所有文件）git add [dir]添加当前目录下所有文件到暂存区git add .删除工作区文件，并将“删除”这个操作放入暂存区git rm [file1] [file2] ...停止追踪文件，但是该文件会保留在工作区，类似gitignore的作用git rm --cached [file]改名文件，并将“改名”这个操作放入暂存区git mv [origin-name] [target-name] 代码提交把暂存区内容提交到仓库， 最常用的提交指令git commit -m &quot;message&quot;提交暂存区中的指定文件到仓库git commit [file1] [file2] ... -m &quot;message&quot;直接将工作区自从上次commit之后的变化，提交到仓库（跳过暂存区）git commit -a使用一次新的commit，替代上一次提交,常用于简单修复如果代码没有任何新变化，则用来改写上一次commit的提交信息git commit --amend -m [message] 分支操作git中的分支是一个非常强大的功能，新建、删除、切换分支速度极快，可以多多使用 列出所有本地分支git branch列出所有远程分支git branch -r列出所有本地和远程分支git branch -a新建一个分支，并且留在当前分支git branch [branch-name]新建一个分支，并切换到新的分支上git checkout -b [branch-name]从某一个commit记录为起点，新建一个分支；其中commit中填入commit的hash或者tag（如果有标签）（下同）git branch [branch-name] [commit]新建一个分支，并于远程的一个分支建立追踪关系git branch --track [branch-name] [remote-branch]切换分支git checkout [branch-name]合并指定分支到当前分支git merge [branch-name]合并指定分支到当前分支，并生成线性的记录git rebase [branch-name]交互式的rebasegit rebase [branch] -i选择某一次提交（任意分支上的），合并到当前分支git cherry-pick [commit]删除分支git branch -d [branch-name]删除远程分支git branch -dr [origin/branch]git push origin --delete [branch-name] 标签标签可以用来给某一次提交添加一个可以追踪的标记，该标记不受分支影响，不会变化，可以在任何情况下被追踪。对于某一次重大提交，常常可以用标签予以标记（如某一次版本发布） 列出所有taggit tag在当前的commit上新建一个标签git tag [tag-name]给指定的commit上新建一个标签git tag [tag-name] [commit]删除本地的一个标签git tag -d [tag-name]删除远程的一个标签git push origin :refs/tags/[tag-name]查看某个标签对应的提交信息git show [tag-name]提交指定tag, remote指远程仓库的名字，一般为origingit push [remote] [tag]提交所有taggit push [remote] --tags以某个标签指定的commit为基点，新建一个分支git branch [branch-name] [tag-name] 查看信息显示有变更的文件git status显示当前分支的版本历史git log显示commit历史，以及每次commit发生变化的文件git log --stat显示指定文件的每一次改动git log -p [file]显示指定文件是什么时间被什么人修改的git blame [file]显示暂存区与工作区的差异git diff显示暂存区与上一次commit之间的差异 （可指定文件）git diff --cached [file]显示工作区与当前分支最新commit之间的差异git diff HEAD显示你今天写了多少行代码git diff --shortstat &quot;@{0 day ago}&quot;显示当前分支最近的几次提交记录（常用来进行恢复）git reflog 远程同步下载远程仓库的所有变动git fetch [remote]显示所有远程仓库git remote -v显示某个远程仓库的信息git remote show [remote]新增一个远程仓库，并命名git remote add [name] [url]拉取远程仓库的变化，并与本地分支合并git pull [remote] [branch]上传本地分支到远程仓库git push [remote] [branch]强行推送当前分支到远程仓库，即使有冲突git push [remote] --force推送所有分支到远程仓库git push [remote] --all 撤销恢复暂存区的指定文件到工作区git checkout [file]恢复某个commit的指定文件到暂存区与工作区git checkout [commit] [file]恢复暂存区的所有文件到工作区git checkout .重置暂存区的指定文件，与上一次commit保持一致，但工作区不变git reset [file]重置工作区与暂存区，与上一次commit保持一致git reset --hard重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变git reset [commit]重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致git reset --hard [commit]新建一个commit，用来撤销指定commit后者的所有变化都将被前者抵消，并且应用到当前分支常用来对远程仓库进行恢复git revert [commit]暂时将未提交的变化移除，稍后再移入git stashgit stash pop 关于git reset指令，其实有 –soft –hard –mixed三种参数，默认为 –mixed参数。具体详细用法可以参考这篇文章 git reset详解 HEAD移动HEAD在git中是一个非常重要的概念，因此在这里把这部分单独列出来。HEAD是git中用来标记当前位置的一个指针。形象的说法就是：你现在在哪，HEAD就指向哪，因为HEAD，git才知道你在哪。 一般情况下，HEAD指向当前分支（上最近的提交），但是在有些时候，我们可以让HEAD指向某一次具体的提交，这也叫做分离HEAD。比如创建分支时，如果不指定commit，那么会在当前HEAD的位置创建分支。 移动HEAD的方法是使用checkout指令，指定一个commid的hash值进行绝对定位git checkout [commit-id]我们也可以使用相对定位，以当前HEAD或分支名等可以追踪位置的标记为基准。 ^代表当前位置的前一个提交git checkout HEAD^git checkout master^我们也可以用 ~[number] 来一次移动多次提交git checkout HEAD~3git checkout master~5 关于HEAD的更多用法可以进一步去搜集资料 后记以上仅仅为git 入门常用的一些指令，熟练之后可以应对一般git的使用场景。在这里依然十分推荐https://learngitbranching.js.org/进行实际操作一次，相信对git的使用有很大帮助。]]></content>
      <categories>
        <category>git学习</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>版本控制</tag>
        <tag>常用指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Hexo和Github pages快速搭建个人博客]]></title>
    <url>%2F2019%2F04%2F09%2F%E7%94%A8Hexo%E5%92%8CGithub%20pages%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[为什么要写博客一直以来都有想写博客的想法，但一方面又觉得自己没有什么技术积累，言之无物，另一方面又担心没有毅力能够坚持下去。终于还是决定先行动起来，即便是记录下日常学习的心得，踩过的坑，也或许对自己对他人有些微帮助 于是今天动手用hexo简单搭建了这样一个静态博客，搭建的过程也并不复杂，感兴趣的朋友可以参照下面步骤搭建一个自己的静态博客 开始搭建准备工作 首先hexo是基于Node.js实现的，因此我们想要用hexo搭建个人主页，首先要安装Node.js 对于windows用户，建议去官网下载安装包，安装时选择 add to path， 添加环境变量 对于mac用户 可以选择使用nvm进行安装，优点在于可以方便的控制node版本（对于搭建个人博客意义不大）$ curl https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh安装好nvm后执行nvm install stable安装最新稳定版node 安装好node后，为了将其发布在Github pages上，我们还需要安装git 对于windows用户，去官网下载 git，为了方便使用命令行，建议安装git bash 对于mac用户，可以用homebrew进行安装brew install git 安装hexo准备工作完成后，我们就可以安装Hexo了npm install -g hexo-cli-g 参数指定以全局方式安装 安装好hexo后，便可以在命令行使用hexo指令123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 其中folder为你想创建的文件夹路径，如果不指定folder，则默认会在当前文件夹创建（要求当前文件夹为空） 新建完成后，文件夹目录结构如下12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml为全局配置文件，可以配置网站的基础信息 scaffolds文件夹存放页面的模版信息 source文件夹中的_posts文件夹用来存放我们的博文 themes文件夹存放页面所使用的主题 配置网站到了这里，我们的网站已经初步成型了，为了看到我们网站的具体样子，我们可以执行hexo server在本地运行一个服务，默认4000端口，信息如下12INFO Start processingINFO Hexo is running at http://localhost:4000 . Press Ctrl+C to stop. 看到这样的提示，代表已经成功运行了，打开浏览器输入 localhost:4000 即可看到我们的页面 但是此时的网站没有名称，作者等一系列信息，需要我们手动配置 打开根目录下的_config.yml 如下123456789101112# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: subtitle:description:keywords:author: language: zh-Hanstimezone: 可以修改各个字段的值，如标题、作者、语言等等。可以给博客起一个喜欢的名字，并落上自己的署名 发布文章 博客配置好后，我们便可以开始书写文章了，用hexo创建一篇新文章也很简单 hexo new [layout] &lt;title&gt;layout不指定的话默认试用post的布局，默认布局可以在_config.yml中修改创建好文章后，我们就可以在source/_posts文件夹下找到并编写了，书写博文使用markdown 文章写好后，我们需要把markdown文件转换成静态的html文件以便显示在网页上，hexo为我们提供了一个简单的指令 hexo generate可以简写为hexo g 在生成好文章后，刷新我们本地打开的博客网站(localhost:4000)，可以看到我们的文章已经可以显示出来啦 部署网站至此我们的博客基本功能已经实现了，但是所有的操作都只能通过本地运行的服务进行查看。为了把博客放到互联网上供所有人浏览，我们还需要将我们的博客部署到服务器上。 一个令人兴奋的消息是，github为我们提供了这样一个静态网站托管的服务，并且完全免费！我们所需要做的，仅仅是拥有一个github账号，并且创建一个用于维护github page的仓库 首先在github上创建一个仓库，仓库名称为 yourName.github.io ，yourName需要替换成你的github昵称 如果想要通过ssh验证，需要先在本机生成ssh密钥，将公钥添加到github账户上 之后需要配置本地博客网站的部署配置，依然是在_config.yml中，在文件最下方找到deploy字段如下12deploy: type: 在type字段中填写 git之后在下一行新增一个字段 repo，填入你刚刚创建的git仓库地址，应该是如下形式123deploy: type: git repo: https://github.com/xxxx/xxx.github.io.git repo字段根据选择的不同协议，可以选择https或者ssh认证 一切都配置完毕后，我们就可以将网站部署到github page上去了！hexo deploy可以简写为 hexo d首次部署需要进行身份验证，如果采用https协议，需要输入github账号密码。如果采用ssh协议则不需要。 如果没有提示什么错误，稍等片刻，我们在浏览器输入与刚刚创建好的仓库的同名域名 xxx.github.io 即可以看到我们创建好的个人网站了！ 个性化域名如果想要为自己的网站设置一个个性化的域名，那么我们需要向域名供应商购买一个域名并且配置相应的dns服务，更多内容可以自行查阅，本文不再过多阐述。 相关阅读hexo官方文档github pages官方指南markdown语法简介]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>node</tag>
        <tag>指南</tag>
      </tags>
  </entry>
</search>
