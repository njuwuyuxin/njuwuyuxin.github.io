<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mind Walker</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://njuwuyuxin.github.io/"/>
  <updated>2020-01-13T08:24:38.646Z</updated>
  <id>https://njuwuyuxin.github.io/</id>
  
  <author>
    <name>吴雨昕</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从零搭建教务抢课系统（四）</title>
    <link href="https://njuwuyuxin.github.io/2019/12/29/%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%95%99%E5%8A%A1%E6%8A%A2%E8%AF%BE%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>https://njuwuyuxin.github.io/2019/12/29/从零搭建教务抢课系统（四）/</id>
    <published>2019-12-29T06:17:18.000Z</published>
    <updated>2020-01-13T08:24:38.646Z</updated>
    
    <content type="html"><![CDATA[<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><hr><p><a href="https://njuwuyuxin.github.io/2019/12/26/%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%95%99%E5%8A%A1%E6%8A%A2%E8%AF%BE%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89/">（一）核心功能：模拟登陆</a><br><a href="https://njuwuyuxin.github.io/2019/12/27/%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%95%99%E5%8A%A1%E6%8A%A2%E8%AF%BE%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89/">（二）使用Cookie进行模拟登录</a><br>（三）获取教务网选课列表<br>（四）循环选课<br>（五）断线重连</p><h6 id="Github链接：-https-github-com-njuwuyuxin-CourseGrabber"><a href="#Github链接：-https-github-com-njuwuyuxin-CourseGrabber" class="headerlink" title="Github链接： https://github.com/njuwuyuxin/CourseGrabber"></a>Github链接： <a href="https://github.com/njuwuyuxin/CourseGrabber" target="_blank" rel="noopener">https://github.com/njuwuyuxin/CourseGrabber</a></h6><h3 id="循环选课"><a href="#循环选课" class="headerlink" title="循环选课"></a>循环选课</h3><p>在成功实现了登陆系统，拉取课程列表之后，我们离成功只差最后一步，只需要模拟浏览器，向对应端口发送选课请求即可。<br>手动在网页上选择任意一门课之后发现，选课请求体结构非常简单，同样为Post请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &#39;method&#39;:&#39;addSpecialitySelect&#39;,</span><br><span class="line">  &#39;classId&#39;:&#39;xxxx&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的classID就是上一篇中提到的后台为每个课程标记的ID，并不是大家平时使用的课程号。好在上一篇中，我们已经对每门课的序号和课程ID进行了映射。</p><p>基本思路理清后，代码的部分就相对非常简单。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">def GrabCourse(courseID,interval&#x3D;0):</span><br><span class="line">    while(True):</span><br><span class="line">        selectCourse_reqdata&#x3D;&#123;&#125;</span><br><span class="line">        selectCourse_reqdata[&#39;method&#39;]&#x3D;&quot;addSpecialitySelect&quot;</span><br><span class="line">        selectCourse_reqdata[&#39;classId&#39;]&#x3D;str(courseID)</span><br><span class="line">        selectResult &#x3D; s.post(host+&#39;student&#x2F;elective&#x2F;selectCourse.do&#39;,selectCourse_reqdata)</span><br><span class="line">        soup &#x3D; BeautifulSoup(selectResult.content,&quot;html.parser&quot;,from_encoding&#x3D;&#39;utf-8&#39;)</span><br><span class="line">        for tag in soup.find_all(&#39;div&#39;):</span><br><span class="line">            if tag.get(&#39;id&#39;)&#x3D;&#x3D;&quot;successMsg&quot;:</span><br><span class="line">                print(&quot;抢课成功！&quot;)</span><br><span class="line">                return</span><br><span class="line">            elif tag.get(&#39;id&#39;)&#x3D;&#x3D;&quot;errMsg&quot;:   </span><br><span class="line">                if tag.string.find(&quot;已经&quot;)!&#x3D;-1:</span><br><span class="line">                    print(&quot;您已经抢到该课程啦~&quot;)</span><br><span class="line">                    exit()</span><br><span class="line">                elif tag.string.find(&quot;错误&quot;)!&#x3D;-1:</span><br><span class="line">                    print(&quot;出现错误，添加失败&quot;)</span><br><span class="line">                    exit()</span><br><span class="line">                else:</span><br><span class="line">                    print(&quot;当前班级已满，仍在为您持续抢课&quot;)</span><br><span class="line">            else:</span><br><span class="line">                pass</span><br><span class="line">        if interval!&#x3D;0:</span><br><span class="line">            time.sleep(interval)</span><br></pre></td></tr></table></figure><p>这里的GrabCourse函数接收两个参数，第一个就是课程ID，第二个为一个可调的时间间隔。为了避免对教务系统造成过大负担（防止被查水表），这里默认设置了每次发送选课请求的时间间隔为1秒。</p><p>同时对每次选课请求的返回进行一下检验，主要分为四种情况：</p><ol><li>选课成功：理想情况</li><li>已经选课：证明课表这已经选中这门课</li><li>班级已满：抢课系统主要针对的正是这种情况，班级满时需要循环发送请求，等待班级空出位置的瞬间。</li><li>出现错误：多为课程ID填写错误，或者选择了其他院系专业课（没有选课权限）等情况</li></ol><p>对每种情况分别处理即可</p><h3 id="其他尝试"><a href="#其他尝试" class="headerlink" title="其他尝试"></a>其他尝试</h3><p>由于之前拉取课程列表时，尝试通过填写其他院系编号来构造请求体，成功拉取到了其他院系的课表，可知教务系统后端对院系方面审核并不十分严格。因此在选课阶段同样进行了类似的尝试（作死），方法同样是在构造选课请求时，填写其他院系课程的课程ID<br>结果：返回“出现错误，添加失败”（笑）<br>可见教务平台至少在选课的时候还是稍微做了一下身份验证。不过至此，整个抢课系统的基本功能已经实现。可以成功登录、获取列表、循环发送选课请求。接下来的工作就是优化人机交互以及断线重连相关功能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;&lt;a href=&quot;https://njuwuyuxin.github.io/2019/12/26/%E4%BB%8E%E9%9B%
      
    
    </summary>
    
      <category term="简单尝试" scheme="https://njuwuyuxin.github.io/categories/%E7%AE%80%E5%8D%95%E5%B0%9D%E8%AF%95/"/>
    
    
      <category term="爬虫" scheme="https://njuwuyuxin.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="抢课系统" scheme="https://njuwuyuxin.github.io/tags/%E6%8A%A2%E8%AF%BE%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="http" scheme="https://njuwuyuxin.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>从零搭建教务抢课系统（三）</title>
    <link href="https://njuwuyuxin.github.io/2019/12/28/%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%95%99%E5%8A%A1%E6%8A%A2%E8%AF%BE%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>https://njuwuyuxin.github.io/2019/12/28/从零搭建教务抢课系统（三）/</id>
    <published>2019-12-27T16:26:23.000Z</published>
    <updated>2020-01-13T08:23:31.953Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p><a href="https://njuwuyuxin.github.io/2019/12/26/%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%95%99%E5%8A%A1%E6%8A%A2%E8%AF%BE%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89/">（一）核心功能：模拟登陆</a><br><a href="https://njuwuyuxin.github.io/2019/12/27/%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%95%99%E5%8A%A1%E6%8A%A2%E8%AF%BE%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89/">（二）使用Cookie进行模拟登录</a><br>（三）获取教务网选课列表<br>（四）循环选课<br>（五）断线重连</p><h6 id="Github链接：-https-github-com-njuwuyuxin-CourseGrabber"><a href="#Github链接：-https-github-com-njuwuyuxin-CourseGrabber" class="headerlink" title="Github链接： https://github.com/njuwuyuxin/CourseGrabber"></a>Github链接： <a href="https://github.com/njuwuyuxin/CourseGrabber" target="_blank" rel="noopener">https://github.com/njuwuyuxin/CourseGrabber</a></h6><h3 id="获取选课列表"><a href="#获取选课列表" class="headerlink" title="获取选课列表"></a>获取选课列表</h3><p>在研究了教务网的js代码以及抓包分析之后，发现教务网拉取专业选课列表的接口接收不同数量的参数（有默认参数）<br>专业选课页面的加载逻辑为，初次进入页面自动发送一条post请求，请求体为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &#39;method&#39;:&#39;specialityCourseList&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该请求只包含调用的方法名，其余均为默认参数，用来拉取默认显示的课程列表</p><p>当用户在下拉选单中手动选择某项之后，会向同一端口再次发送一条post请求，请求体为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &#39;method&#39;:&#39;specialityCourseList&#39;,</span><br><span class="line">  &#39;specialityCode&#39;:&#39;221&#39;,</span><br><span class="line">  &#39;courseGrade&#39;:&#39;2016</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次请求体中包含了所在专业的专业编号，以及对应年级</p><h4 id="解析网页获得课程列表"><a href="#解析网页获得课程列表" class="headerlink" title="解析网页获得课程列表"></a>解析网页获得课程列表</h4><p>按照请求格式构造好请求体中，response返回的HTML文档就是包含了课程列表的页面<br>这里使用了Beautiful Soup进行解析，可以看到课程列表是以<tr>、 <td>标签的形式进行显示，按对应格式解析即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">soup &#x3D; BeautifulSoup(courseList.content,&quot;html.parser&quot;,from_encoding&#x3D;&#39;utf-8&#39;)</span><br><span class="line">soup &#x3D; BeautifulSoup(courseList.content,&quot;html.parser&quot;,from_encoding&#x3D;&#39;utf-8&#39;)</span><br><span class="line">trs &#x3D; soup.find_all(&#39;tr&#39;,&#123;&#39;class&#39;:&#39;TABLE_TR_01&#39;&#125;)</span><br><span class="line">print(&quot;序号\t课程号\t\t课程名\t\t\t学分\t学时\t类型\t开课院系&quot;)</span><br><span class="line">for tr in trs:</span><br><span class="line">    tds &#x3D; tr.find_all(&#39;td&#39;)</span><br><span class="line">    courseNo &#x3D; tds[0].find(&#39;a&#39;).find(&#39;u&#39;).string</span><br><span class="line">    if(tds[1].string.__len__()&lt;&#x3D;7):</span><br><span class="line">        print(str(trs.index(tr)+1)+&#39;\t&#39;+courseNo+&#39;\t&#39;+tds[1].string+&#39;\t\t&#39;+tds[2].string+&#39;\t&#39;+tds[3].string+&#39;\t&#39;+tds[4].string+&#39;\t&#39;+tds[6].string)</span><br><span class="line">    else:</span><br><span class="line">        print(str(trs.index(tr)+1)+&#39;\t&#39;+courseNo+&#39;\t&#39;+tds[1].string+&#39;\t&#39;+tds[2].string+&#39;\t&#39;+tds[3].string+&#39;\t&#39;+tds[4].string+&#39;\t&#39;+tds[6].string)</span><br><span class="line">    click_td &#x3D; tr.find(&#39;td&#39;,&#123;&#39;onclick&#39;:True&#125;)</span><br><span class="line">    if click_td&#x3D;&#x3D;None:</span><br><span class="line">        courseIdList.append(&quot;&quot;)</span><br><span class="line">        pass</span><br><span class="line">    else:</span><br><span class="line">        # print(click_td[&#39;onclick&#39;])</span><br><span class="line">        js &#x3D; click_td[&#39;onclick&#39;]</span><br><span class="line">        args &#x3D; js.split(&#39;,&#39;)</span><br><span class="line">        courseID &#x3D; args[4][0:5]</span><br><span class="line">        courseIdList.append(courseID)</span><br></pre></td></tr></table></figure><p>由于教务网后端较为特殊，选课的请求体中课程id有单独编号需要提取，而不是使用课程编号（后文有讲），因此额外做了一些解析，HTML解析这里不具有普遍参考价值.</p><p>获取的课程列表展示如下：<br><img src="https://upload-images.jianshu.io/upload_images/16734657-21ed6aa2ccdb6724.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="课程列表"></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.crummy.com/software/BeautifulSoup/bs3/documentation.zh.html" target="_blank" rel="noopener">Beautiful Soup4 中文文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h3 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://njuwuyuxin.github.io/2019/12/26/%E4%BB%8E%E9%9B%
      
    
    </summary>
    
      <category term="简单尝试" scheme="https://njuwuyuxin.github.io/categories/%E7%AE%80%E5%8D%95%E5%B0%9D%E8%AF%95/"/>
    
    
      <category term="爬虫" scheme="https://njuwuyuxin.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="抢课系统" scheme="https://njuwuyuxin.github.io/tags/%E6%8A%A2%E8%AF%BE%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="http" scheme="https://njuwuyuxin.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>从零搭建教务抢课系统（二）</title>
    <link href="https://njuwuyuxin.github.io/2019/12/27/%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%95%99%E5%8A%A1%E6%8A%A2%E8%AF%BE%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://njuwuyuxin.github.io/2019/12/27/从零搭建教务抢课系统（二）/</id>
    <published>2019-12-27T12:56:17.000Z</published>
    <updated>2019-12-27T13:06:57.878Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p><a href="https://njuwuyuxin.github.io/2019/12/26/%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%95%99%E5%8A%A1%E6%8A%A2%E8%AF%BE%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89/">（一）核心功能：模拟登陆</a><br><a href="https://njuwuyuxin.github.io/2019/12/27/%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%95%99%E5%8A%A1%E6%8A%A2%E8%AF%BE%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89/">（二）使用Cookie进行模拟登录</a><br>（三）获取教务网选课列表<br>（四）循环选课<br>（五）断线重连</p><h6 id="Github链接：-https-github-com-njuwuyuxin-CourseGrabber"><a href="#Github链接：-https-github-com-njuwuyuxin-CourseGrabber" class="headerlink" title="Github链接： https://github.com/njuwuyuxin/CourseGrabber"></a>Github链接： <a href="https://github.com/njuwuyuxin/CourseGrabber" target="_blank" rel="noopener">https://github.com/njuwuyuxin/CourseGrabber</a></h6><h3 id="使用cookie模拟登录"><a href="#使用cookie模拟登录" class="headerlink" title="使用cookie模拟登录"></a>使用cookie模拟登录</h3><p>在成功实现了基本登陆后，为了方便使用，这里尝试使用cookie进行登录</p><p>首先我们在创建session时，初始cookie为空，可以打印进行查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s &#x3D; requests.session()</span><br><span class="line">print(s.cookies.get_dict())</span><br></pre></td></tr></table></figure><p>在构造登陆请求体，成功登陆之后，session中的cookies被自动更新，可以打印查看，南大教务平台的Cookie形如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &#39;user_id&#39;:&#39;&quot;1612xxxxx 1577448172273&quot;&#39;,</span><br><span class="line">  &#39;ARRAffinity&#39;:&#39;80372ade9da56061dc1cfb0f216b6917726c2c01e3d804e60cad7fce0e0af662&#39;,</span><br><span class="line">  &#39;JSESSIONID&#39;:&#39;8D6204D5EDBE04DC6088DB9BE43A5924&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到共有三个表项，这里在成功登录之后，手动将其保存到本地文件中。这里没有使用相关库函数，而是手动实现了简单的cookie存储</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def SaveCookie(session):</span><br><span class="line">    with open(&quot;.cookie&quot;,&#39;w&#39;) as f:</span><br><span class="line">        for key,val in session.cookies.get_dict().items():</span><br><span class="line">            f.write(key+&quot;:&quot;+val+&#39;\n&#39;)</span><br></pre></td></tr></table></figure><p>同时实现了从文件读取cookie的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def GetCookie(session):</span><br><span class="line">    cookie &#x3D; &#123;&#125;</span><br><span class="line">    if &quot;.cookie&quot; not in os.listdir():</span><br><span class="line">        return cookie</span><br><span class="line">    with open(&quot;.cookie&quot;,&#39;r&#39;) as f:</span><br><span class="line">        for line in f:</span><br><span class="line">            line &#x3D; line.replace(&#39;\n&#39;,&#39;&#39;).replace(&#39;\r&#39;,&#39;&#39;)</span><br><span class="line">            item &#x3D; line.split(&#39;:&#39;)</span><br><span class="line">            cookie[item[0]] &#x3D; item[1]</span><br><span class="line">    return cookie</span><br></pre></td></tr></table></figure><p>cookie的保存与读取实现之后，登陆部分的逻辑可以改为：</p><ol><li>首先检查本地是否存在cookie</li><li>如果存在cookie，尝试使用cookie登录；如果不存在，直接使用账号密码登录</li><li>如果cookie登录成功，直接进入系统；如果cookie已过期，则重新使用账号密码登录，并更新本地cookie</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#获取cookie，如果本地有cookie，尝试使用cookie登录</span><br><span class="line">    c &#x3D; GetCookie(session)</span><br><span class="line">    session.cookies.update(c)</span><br><span class="line">    if c:</span><br><span class="line">        rs &#x3D; session.get(host+&quot;student&#x2F;index.do&quot;)    #教务平台首页，如果能够进入，说明已成功登录</span><br><span class="line">        if rs.content.__len__() &gt; 5000:</span><br><span class="line">            print(&quot;登陆成功!&quot;)</span><br><span class="line">            return True</span><br><span class="line">        else:</span><br><span class="line">            print(&quot;登录已过期，请重新登录&quot;)</span><br></pre></td></tr></table></figure><p>这样我们基本实现了使用cookie进行登录，避免了重复输入账号密码及验证码的验证</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h3 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://njuwuyuxin.github.io/2019/12/26/%E4%BB%8E%E9%9B%
      
    
    </summary>
    
      <category term="简单尝试" scheme="https://njuwuyuxin.github.io/categories/%E7%AE%80%E5%8D%95%E5%B0%9D%E8%AF%95/"/>
    
    
      <category term="爬虫" scheme="https://njuwuyuxin.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="抢课系统" scheme="https://njuwuyuxin.github.io/tags/%E6%8A%A2%E8%AF%BE%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="http" scheme="https://njuwuyuxin.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>从零搭建教务抢课系统（一）</title>
    <link href="https://njuwuyuxin.github.io/2019/12/26/%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%95%99%E5%8A%A1%E6%8A%A2%E8%AF%BE%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://njuwuyuxin.github.io/2019/12/26/从零搭建教务抢课系统（一）/</id>
    <published>2019-12-26T06:52:16.000Z</published>
    <updated>2019-12-27T13:03:51.355Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p><a href="https://njuwuyuxin.github.io/2019/12/26/%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%95%99%E5%8A%A1%E6%8A%A2%E8%AF%BE%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89/">（一）核心功能：模拟登陆</a><br><a href="https://njuwuyuxin.github.io/2019/12/27/%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%95%99%E5%8A%A1%E6%8A%A2%E8%AF%BE%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89/">（二）使用Cookie进行模拟登录</a><br>（三）获取教务网选课列表<br>（四）循环选课<br>（五）断线重连</p><h6 id="Github链接：-https-github-com-njuwuyuxin-CourseGrabber"><a href="#Github链接：-https-github-com-njuwuyuxin-CourseGrabber" class="headerlink" title="Github链接： https://github.com/njuwuyuxin/CourseGrabber"></a>Github链接： <a href="https://github.com/njuwuyuxin/CourseGrabber" target="_blank" rel="noopener">https://github.com/njuwuyuxin/CourseGrabber</a></h6><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>响应群里学弟学妹号召，心血来潮想做一个南大教务网的抢课系统。在仔细研究了一下教务平台的js代码之后，发现几乎没有什么防护措施，于是便开始着手尝试起来。</p><p>抢课系统的主要思路无非就是以下几步：</p><ol><li>模拟教务平台的网页登录，获取session</li><li>登入平台后拉取各个课程列表</li><li>找到对应课程编号，构造选课请求体，循环发送</li></ol><p>为了方便调试检验，还使用了wireshark进行简单抓包（可省略），有需要的小伙伴可以自行下载</p><h3 id="二、模拟登陆"><a href="#二、模拟登陆" class="headerlink" title="二、模拟登陆"></a>二、模拟登陆</h3><p>首先进入教务网登陆界面，尝试一次普通登录<br><img src="https://s2.ax1x.com/2019/12/26/lAPbLT.png" alt="登录请求体.png"><br>可以发现登录的请求体主要由四个表项组成，returnUrl暂无具体含义，默认为null，其余均为用户提交表单。<br>这里唯一比较棘手的一点是验证码的获取。</p><h4 id="验证码获取"><a href="#验证码获取" class="headerlink" title="验证码获取"></a>验证码获取</h4><p>南大教务平台的验证码是通过向后端jsp请求获得。因此在代码里我们同样用模拟浏览器的方式进行请求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#首先创建一个session</span><br><span class="line">session &#x3D; requests.session()</span><br><span class="line"></span><br><span class="line">#取得验证码图片</span><br><span class="line">now_time &#x3D; str(int(time.time()))</span><br><span class="line">pic_url &#x3D; host + &#39;ValidateCode.jsp&#39;</span><br><span class="line">pic &#x3D; session.get(pic_url).content</span><br><span class="line">im &#x3D; Image.open(BytesIO(pic))   #直接打开图片</span><br><span class="line">    im.show()</span><br><span class="line">filename &#x3D; &#39;&#39; + now_time + &#39;.jpg&#39;  </span><br><span class="line">with open(filename, &#39;wb&#39;) as f:</span><br><span class="line">    f.write(pic)</span><br></pre></td></tr></table></figure><p>这里首先创建了一个session，确保获取验证码和登录请求为同一个session，向对应jsp请求，将请求获得的图片保存在本地。<br>之后尝试使用了ocr进行验证码的自动识别，由于验证码干扰严重，OCR无法识别，因而放弃</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#尝试使用OCR自动识别验证码，但是由于验证码干扰较多，不能正确识别，因此采用手动输入方式</span><br><span class="line"># img &#x3D; Image.open(filename)</span><br><span class="line"># img&#x3D;img.convert(&#39;L&#39;)</span><br><span class="line"># vcode &#x3D; pytesseract.image_to_string(img)  # 使用ocr技术将图片中的验证码读取出来</span><br><span class="line"># time.sleep(0.3) </span><br><span class="line"># print(vcode)</span><br></pre></td></tr></table></figure><p>OCR无法自动识别，那么我们只能采用手动输入验证码的方式，每次登陆时根据获取到本地的验证码进行输入，登陆后自动删除临时图片。<br>同时发现验证码大约有100秒有效时间，因此需及时输入，否则验证码过期需要重新获取</p><h4 id="登录请求体构造"><a href="#登录请求体构造" class="headerlink" title="登录请求体构造"></a>登录请求体构造</h4><p>之后我们就可以构造登录请求体，这里为了方便测试，可以选择性读取存储用户信息的配置文件，也可以控制台进行输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">login_data&#x3D;&#123;&#125;</span><br><span class="line">files &#x3D; os.listdir()</span><br><span class="line">if &quot;user.cfg&quot; in files:</span><br><span class="line">    with open(&quot;user.cfg&quot;,&#39;r&#39;) as f:</span><br><span class="line">        for line in f:</span><br><span class="line">            items &#x3D; line.split(&quot;:&quot;)</span><br><span class="line">            items[1]&#x3D;items[1].replace(&#39;\n&#39;,&#39;&#39;).replace(&#39;\r&#39;,&#39;&#39;)</span><br><span class="line">            login_data[items[0]]&#x3D;items[1]</span><br><span class="line">else:</span><br><span class="line">    print(&quot;请输入用户名&quot;)</span><br><span class="line">    login_data[&#39;userName&#39;]&#x3D;input()</span><br><span class="line">    print(&quot;请输入密码&quot;)</span><br><span class="line">    login_data[&#39;password&#39;]&#x3D;input()</span><br><span class="line">        </span><br><span class="line">login_data[&#39;retrunURL&#39;]&#x3D;&quot;null&quot;</span><br><span class="line">print(&quot;请输入验证码(Please enter the ValidateCode)&quot;)</span><br><span class="line">vcode&#x3D;input()</span><br><span class="line">os.remove(filename) #输入完验证码后自动删除本地图片   </span><br><span class="line">login_data[&#39;ValidateCode&#39;]&#x3D;vcode</span><br></pre></td></tr></table></figure><h4 id="发送登录请求"><a href="#发送登录请求" class="headerlink" title="发送登录请求"></a>发送登录请求</h4><p>构造好请求体之后，我们将对应post请求发送到后端端口即可，这里由于无论登陆成功或失败，都会返回200表示请求成功，并不代表登陆成功。而返回的response分别对应错误页面的html和成功页面的html，因此这里简单对response长度进行判断来判断是否登陆成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#发送登录请求</span><br><span class="line">response &#x3D; session.post(host+&quot;login.do&quot;,login_data)</span><br><span class="line">if response.content.__len__() &gt; 1100:</span><br><span class="line">    print(&quot;登陆成功!&quot;)</span><br><span class="line">    return True</span><br><span class="line">else:</span><br><span class="line">    print(&quot;登录失败，请检查账号密码及验证码&quot;)</span><br><span class="line">    return False</span><br></pre></td></tr></table></figure><p>输入完用户信息后，成功登录后，wireshark抓包可以看到对应数据包<br><img src="https://s2.ax1x.com/2019/12/26/lAEzMn.png" alt="lAEzMn.png"><br>打印请求体后，可以发现正是教务平台登陆成功后的主页的html，至此，抢课系统的核心登录部分已经完成。之后可以解析HTML获得相关信息（类似爬虫），或发送选课请求等均可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h3 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://njuwuyuxin.github.io/2019/12/26/%E4%BB%8E%E9%9B%
      
    
    </summary>
    
      <category term="简单尝试" scheme="https://njuwuyuxin.github.io/categories/%E7%AE%80%E5%8D%95%E5%B0%9D%E8%AF%95/"/>
    
    
      <category term="爬虫" scheme="https://njuwuyuxin.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="抢课系统" scheme="https://njuwuyuxin.github.io/tags/%E6%8A%A2%E8%AF%BE%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="http" scheme="https://njuwuyuxin.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>nodejs+express框架搭建简单后端服务</title>
    <link href="https://njuwuyuxin.github.io/2019/06/07/nodejs-express%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%E7%AE%80%E5%8D%95%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1/"/>
    <id>https://njuwuyuxin.github.io/2019/06/07/nodejs-express框架搭建简单后端服务/</id>
    <published>2019-06-07T08:51:40.000Z</published>
    <updated>2019-12-26T10:55:30.583Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="Node安装"><a href="#Node安装" class="headerlink" title="Node安装"></a>Node安装</h2><p>由于后端服务通常部署在linux服务器上，因此简单说下linux环境下node的安装。 可以选择去官网下载编译好的二进制文件，软链接到环境目录下。也可以使用apt工具直接安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install node</span><br></pre></td></tr></table></figure><h3 id="Express框架"><a href="#Express框架" class="headerlink" title="Express框架"></a>Express框架</h3><p>express是一个功能十分强大的框架，可以同时兼顾前后端开发。但由于这次只是想用express实现后端服务，因此不需要express提供的前端开发模板相关功能。所以只是在项目中引入了express模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express</span><br></pre></td></tr></table></figure><p>之后就可以在项目中通过require的方式使用express模块</p><h4 id="Express的使用"><a href="#Express的使用" class="headerlink" title="Express的使用"></a>Express的使用</h4><p>首先需要在需要的文件中引入express模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var express &#x3D; require(&#39;epxress&#39;);</span><br><span class="line">var app &#x3D; express();</span><br></pre></td></tr></table></figure><p>之后需要创建一个http服务器，但是由于我的网站而言，需要提供https服务，因此创建了一个https服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var httpsServer &#x3D; https.createServer(options, app);</span><br><span class="line">httpsServer.listen(parseInt(config.port),function()&#123;</span><br><span class="line">    console.log(&quot;Https server is running on: https:&#x2F;&#x2F;localhost:&quot;+config.port);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>创建https服务器时需要一个额外参数option，用来指定服务器所需证书的路径，只有证书有效，才能创建https服务。<br>至于端口号，可以自行指定，由于网站前端运行在默认443端口，因此选择不冲突的端口即可。</p><p>创建好服务器之后，我们就可以用app实例去监听对应的请求。<br>express框架为我们实现了路由功能，因此可以很方便的通过路径来区分各种请求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app.get(&#39;&#x2F;api&#x2F;activities&#39;,newsApi.getActivities);</span><br><span class="line">app.get(&#39;&#x2F;api&#x2F;activityCards&#39;,newsApi.getActivityCards);</span><br><span class="line">app.post(&#39;&#x2F;api&#x2F;reviewCards&#39;,newsApi.getReviewCards);</span><br><span class="line"></span><br><span class="line">function getActivities(req, res)&#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    res.send(&#39;...&#39;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过调用app的get和post方法，我们可以处理get和post请求，第一个参数即为路由的路径，第二个参数为一个函数闭包，用来处理对应的请求。该闭包会接受两个参数req和res，分别对应请求体和返回的内容</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;Node安装&quot;&gt;&lt;a href=&quot;#Node安装&quot; class=&quot;headerlink&quot; title=&quot;Node安装&quot;&gt;&lt;/a&gt;Node安装&lt;/h2&gt;&lt;p&gt;由于后端服务通常部署在linux服务器上，因此简单说下linux环境下node的安装。 可以选择去
      
    
    </summary>
    
      <category term="后端学习" scheme="https://njuwuyuxin.github.io/categories/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="nodejs" scheme="https://njuwuyuxin.github.io/tags/nodejs/"/>
    
      <category term="express" scheme="https://njuwuyuxin.github.io/tags/express/"/>
    
      <category term="后端" scheme="https://njuwuyuxin.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Git快速上手</title>
    <link href="https://njuwuyuxin.github.io/2019/04/18/git%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"/>
    <id>https://njuwuyuxin.github.io/2019/04/18/git快速上手/</id>
    <published>2019-04-18T06:54:47.000Z</published>
    <updated>2019-12-26T09:49:44.718Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>git作为一个先进的版本管理工具，已经被广泛应用在大量项目中。近来发现了一个非常不错的git学习网站，虽然比较基础，但是可视化的界面能够帮助新人快速理解git每项指令的功能，同时也可以一定程度上的查漏补缺。<br>网站地址：<a href="https://learngitbranching.js.org/" target="_blank" rel="noopener">https://learngitbranching.js.org/</a><br>而本文也记录了一些常用的git指令和使用技巧</p><h2 id="常用git指令"><a href="#常用git指令" class="headerlink" title="常用git指令"></a>常用git指令</h2><h3 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h3><p>在当前目录初始化一个git仓库<br><code>git init</code><br>新建一个目录，初始化一个git仓库<br><code>git init [projectName]</code><br>用于从远程仓库进行克隆，一般可以选择通过https或者ssh方式<br><code>git clone [url]</code> </p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>对于刚安装git的新人，一般需要配置邮箱和用户名，建议使用全局方式配置<br><code>git conifg [--global] user.name &quot;[username]&quot;</code><br><code>git conifg [--global] user.email &quot;[email]&quot;</code><br>可以查看当前的git配置<br><code>git config --list</code><br>可以直接编辑git配置文件，之前通过命令行配置的在此也可以看到<br><code>git config -e [--global]</code> </p><h3 id="增加、删除文件"><a href="#增加、删除文件" class="headerlink" title="增加、删除文件"></a>增加、删除文件</h3><p>这里需要简单介绍一下git中工作区和暂存区的概念</p><ul><li>工作区可以简单理解为你在当前仓库的种种改动，git可以检测到但是并未将之准备为下次提交的内容。需要用户将之添加到暂存区。</li><li>暂存区可以简单理解为，下次执行提交中会被提交上去的文件。</li><li>整个工作流为： 你修改了某个文件 -&gt; 该文件变为工作区文件 -&gt; 你添加该文件进入暂存区 -&gt; 提交暂存区文件，该文件被提交</li></ul><p>添加指定文件到暂存区<br><code>git add [file1] [file2] ...</code><br>添加指定目录到暂存区（包含该目录下所有文件）<br><code>git add [dir]</code><br>添加当前目录下所有文件到暂存区<br><code>git add .</code><br>删除工作区文件，并将“删除”这个操作放入暂存区<br><code>git rm [file1] [file2] ...</code><br>停止追踪文件，但是该文件会保留在工作区，类似gitignore的作用<br><code>git rm --cached [file]</code><br>改名文件，并将“改名”这个操作放入暂存区<br><code>git mv [origin-name] [target-name]</code></p><h3 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h3><p>把暂存区内容提交到仓库， 最常用的提交指令<br><code>git commit -m &quot;message&quot;</code><br>提交暂存区中的指定文件到仓库<br><code>git commit [file1] [file2] ... -m &quot;message&quot;</code><br>直接将工作区自从上次commit之后的变化，提交到仓库（跳过暂存区）<br><code>git commit -a</code><br>使用一次新的commit，替代上一次提交,常用于简单修复<br>如果代码没有任何新变化，则用来改写上一次commit的提交信息<br><code>git commit --amend -m [message]</code></p><h3 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h3><p>git中的分支是一个非常强大的功能，新建、删除、切换分支速度极快，可以多多使用</p><p>列出所有本地分支<br><code>git branch</code><br>列出所有远程分支<br><code>git branch -r</code><br>列出所有本地和远程分支<br><code>git branch -a</code><br>新建一个分支，并且留在当前分支<br><code>git branch [branch-name]</code><br>新建一个分支，并切换到新的分支上<br><code>git checkout -b [branch-name]</code><br>从某一个commit记录为起点，新建一个分支；其中commit中填入commit的hash或者tag（如果有标签）（下同）<br><code>git branch [branch-name] [commit]</code><br>新建一个分支，并于远程的一个分支建立追踪关系<br><code>git branch --track [branch-name] [remote-branch]</code><br>切换分支<br><code>git checkout [branch-name]</code><br>合并指定分支到当前分支<br><code>git merge [branch-name]</code><br>合并指定分支到当前分支，并生成线性的记录<br><code>git rebase [branch-name]</code><br>交互式的rebase<br><code>git rebase [branch] -i</code><br>选择某一次提交（任意分支上的），合并到当前分支<br><code>git cherry-pick [commit]</code><br>删除分支<br><code>git branch -d [branch-name]</code><br>删除远程分支<br><code>git branch -dr [origin/branch]</code><br><code>git push origin --delete [branch-name]</code></p><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>标签可以用来给某一次提交添加一个可以追踪的标记，该标记不受分支影响，不会变化，可以在任何情况下被追踪。对于某一次重大提交，常常可以用标签予以标记（如某一次版本发布）</p><p>列出所有tag<br><code>git tag</code><br>在当前的commit上新建一个标签<br><code>git tag [tag-name]</code><br>给指定的commit上新建一个标签<br><code>git tag [tag-name] [commit]</code><br>删除本地的一个标签<br><code>git tag -d [tag-name]</code><br>删除远程的一个标签<br><code>git push origin :refs/tags/[tag-name]</code><br>查看某个标签对应的提交信息<br><code>git show [tag-name]</code><br>提交指定tag, remote指远程仓库的名字，一般为origin<br><code>git push [remote] [tag]</code><br>提交所有tag<br><code>git push [remote] --tags</code><br>以某个标签指定的commit为基点，新建一个分支<br><code>git branch [branch-name] [tag-name]</code></p><h3 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h3><p>显示有变更的文件<br><code>git status</code><br>显示当前分支的版本历史<br><code>git log</code><br>显示commit历史，以及每次commit发生变化的文件<br><code>git log --stat</code><br>显示指定文件的每一次改动<br><code>git log -p [file]</code><br>显示指定文件是什么时间被什么人修改的<br><code>git blame [file]</code><br>显示暂存区与工作区的差异<br><code>git diff</code><br>显示暂存区与上一次commit之间的差异 （可指定文件）<br><code>git diff --cached [file]</code><br>显示工作区与当前分支最新commit之间的差异<br><code>git diff HEAD</code><br>显示你今天写了多少行代码<br><code>git diff --shortstat &quot;@{0 day ago}&quot;</code><br>显示当前分支最近的几次提交记录（常用来进行恢复）<br><code>git reflog</code></p><h3 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h3><p>下载远程仓库的所有变动<br><code>git fetch [remote]</code><br>显示所有远程仓库<br><code>git remote -v</code><br>显示某个远程仓库的信息<br><code>git remote show [remote]</code><br>新增一个远程仓库，并命名<br><code>git remote add [name] [url]</code><br>拉取远程仓库的变化，并与本地分支合并<br><code>git pull [remote] [branch]</code><br>上传本地分支到远程仓库<br><code>git push [remote] [branch]</code><br>强行推送当前分支到远程仓库，即使有冲突<br><code>git push [remote] --force</code><br>推送所有分支到远程仓库<br><code>git push [remote] --all</code></p><h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><p>恢复暂存区的指定文件到工作区<br><code>git checkout [file]</code><br>恢复某个commit的指定文件到暂存区与工作区<br><code>git checkout [commit] [file]</code><br>恢复暂存区的所有文件到工作区<br><code>git checkout .</code><br>重置暂存区的指定文件，与上一次commit保持一致，但工作区不变<br><code>git reset [file]</code><br>重置工作区与暂存区，与上一次commit保持一致<br><code>git reset --hard</code><br>重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变<br><code>git reset [commit]</code><br>重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致<br><code>git reset --hard [commit]</code><br>新建一个commit，用来撤销指定commit<br>后者的所有变化都将被前者抵消，并且应用到当前分支<br>常用来对远程仓库进行恢复<br><code>git revert [commit]</code><br>暂时将未提交的变化移除，稍后再移入<br><code>git stash</code><br><code>git stash pop</code></p><p>关于git reset指令，其实有 –soft –hard –mixed三种参数，默认为 –mixed参数。<br>具体详细用法可以参考这篇文章 <a href="https://segmentfault.com/a/1190000009658888" target="_blank" rel="noopener">git reset详解</a></p><h3 id="HEAD移动"><a href="#HEAD移动" class="headerlink" title="HEAD移动"></a>HEAD移动</h3><p>HEAD在git中是一个非常重要的概念，因此在这里把这部分单独列出来。<br>HEAD是git中用来标记当前位置的一个指针。<br>形象的说法就是：你现在在哪，HEAD就指向哪，因为HEAD，git才知道你在哪。</p><p>一般情况下，HEAD指向当前分支（上最近的提交），但是在有些时候，我们可以让HEAD指向某一次具体的提交，这也叫做分离HEAD。比如创建分支时，如果不指定commit，那么会在当前HEAD的位置创建分支。</p><p>移动HEAD的方法是使用checkout指令，指定一个commid的hash值进行绝对定位<br><code>git checkout [commit-id]</code><br>我们也可以使用相对定位，以当前HEAD或分支名等可以追踪位置的标记为基准。 ^代表当前位置的前一个提交<br><code>git checkout HEAD^</code><br><code>git checkout master^</code><br>我们也可以用 <del>[number] 来一次移动多次提交<br>`git checkout HEAD</del>3<code></code>git checkout master~5`</p><p>关于HEAD的更多用法可以进一步去搜集资料</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>以上仅仅为git 入门常用的一些指令，熟练之后可以应对一般git的使用场景。<br>在这里依然十分推荐<a href="https://learngitbranching.js.org/" target="_blank" rel="noopener">https://learngitbranching.js.org/</a>进行实际操作一次，相信对git的使用有很大帮助。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;git作为一个先进的版本管理工具，已经被广泛应用在大量项目中。近来发现了一个非常不错的git学习网站，虽然比较基础，但是可视化的界
      
    
    </summary>
    
      <category term="git学习" scheme="https://njuwuyuxin.github.io/categories/git%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="git" scheme="https://njuwuyuxin.github.io/tags/git/"/>
    
      <category term="版本控制" scheme="https://njuwuyuxin.github.io/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
      <category term="常用指令" scheme="https://njuwuyuxin.github.io/tags/%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>用Hexo和Github pages快速搭建个人博客</title>
    <link href="https://njuwuyuxin.github.io/2019/04/09/%E7%94%A8Hexo%E5%92%8CGithub%20pages%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://njuwuyuxin.github.io/2019/04/09/用Hexo和Github pages快速搭建个人博客/</id>
    <published>2019-04-09T12:07:32.000Z</published>
    <updated>2019-06-07T07:54:30.208Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="为什么要写博客"><a href="#为什么要写博客" class="headerlink" title="为什么要写博客"></a>为什么要写博客</h2><p>一直以来都有想写博客的想法，但一方面又觉得自己没有什么技术积累，言之无物，另一方面又担心没有毅力能够坚持下去。终于还是决定先行动起来，即便是记录下日常学习的心得，踩过的坑，也或许对自己对他人有些微帮助</p><p>于是今天动手用hexo简单搭建了这样一个静态博客，搭建的过程也并不复杂，感兴趣的朋友可以参照下面步骤搭建一个自己的静态博客</p><h2 id="开始搭建"><a href="#开始搭建" class="headerlink" title="开始搭建"></a>开始搭建</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul><li><p>首先hexo是基于Node.js实现的，因此我们想要用hexo搭建个人主页，首先要安装Node.js</p><ul><li>对于windows用户，建议去官网下载安装包，安装时选择 add to path， 添加环境变量</li><li>对于mac用户 可以选择使用nvm进行安装，优点在于可以方便的控制node版本（对于搭建个人博客意义不大）<br><code>$ curl https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh</code><br>安装好nvm后执行<br><code>nvm install stable</code><br>安装最新稳定版node</li></ul></li><li><p>安装好node后，为了将其发布在Github pages上，我们还需要安装git</p><ul><li>对于windows用户，去官网下载 <a href="https://git-scm.com/download/win" target="_blank" rel="noopener">git</a>，为了方便使用命令行，建议安装git bash</li><li>对于mac用户，可以用homebrew进行安装<br><code>brew install git</code></li></ul></li></ul><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><p>准备工作完成后，我们就可以安装Hexo了<br><code>npm install -g hexo-cli</code><br>-g 参数指定以全局方式安装</p><p>安装好hexo后，便可以在命令行使用hexo指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br><span class="line">cd &lt;folder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>其中folder为你想创建的文件夹路径，如果不指定folder，则默认会在当前文件夹创建（要求当前文件夹为空）</p><p>新建完成后，文件夹目录结构如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><ul><li>_config.yml为全局配置文件，可以配置网站的基础信息</li><li>scaffolds文件夹存放页面的模版信息</li><li>source文件夹中的_posts文件夹用来存放我们的博文</li><li>themes文件夹存放页面所使用的主题</li></ul><h3 id="配置网站"><a href="#配置网站" class="headerlink" title="配置网站"></a>配置网站</h3><p>到了这里，我们的网站已经初步成型了，为了看到我们网站的具体样子，我们可以执行<br><code>hexo server</code><br>在本地运行一个服务，默认4000端口，信息如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http:&#x2F;&#x2F;localhost:4000 . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure><p>看到这样的提示，代表已经成功运行了，打开浏览器输入 localhost:4000 即可看到我们的页面</p><p>但是此时的网站没有名称，作者等一系列信息，需要我们手动配置</p><p>打开根目录下的_config.yml 如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Hexo Configuration</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;configuration.html</span><br><span class="line">## Source: https:&#x2F;&#x2F;github.com&#x2F;hexojs&#x2F;hexo&#x2F;</span><br><span class="line"></span><br><span class="line"># Site</span><br><span class="line">title: </span><br><span class="line">subtitle:</span><br><span class="line">description:</span><br><span class="line">keywords:</span><br><span class="line">author: </span><br><span class="line">language: zh-Hans</span><br><span class="line">timezone:</span><br></pre></td></tr></table></figure><p>  可以修改各个字段的值，如标题、作者、语言等等。可以给博客起一个喜欢的名字，并落上自己的署名</p><h3 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h3><p>  博客配置好后，我们便可以开始书写文章了，用hexo创建一篇新文章也很简单<br>  <code>hexo new [layout] &lt;title&gt;</code><br>layout不指定的话默认试用post的布局，默认布局可以在_config.yml中修改<br>创建好文章后，我们就可以在source/_posts文件夹下找到并编写了，书写博文使用markdown</p><pre><code>文章写好后，我们需要把markdown文件转换成静态的html文件以便显示在网页上，hexo为我们提供了一个简单的指令</code></pre><p><code>hexo generate</code><br>可以简写为<code>hexo g</code> </p><p>在生成好文章后，刷新我们本地打开的博客网站(localhost:4000)，可以看到我们的文章已经可以显示出来啦</p><h3 id="部署网站"><a href="#部署网站" class="headerlink" title="部署网站"></a>部署网站</h3><p>至此我们的博客基本功能已经实现了，但是所有的操作都只能通过本地运行的服务进行查看。为了把博客放到互联网上供所有人浏览，我们还需要将我们的博客部署到服务器上。</p><p>一个令人兴奋的消息是，github为我们提供了这样一个静态网站托管的服务，并且完全免费！<br>我们所需要做的，仅仅是拥有一个github账号，并且创建一个用于维护github page的仓库</p><ul><li>首先在github上创建一个仓库，仓库名称为 yourName.github.io ，yourName需要替换成你的github昵称</li><li>如果想要通过ssh验证，需要先在本机生成ssh密钥，将公钥添加到github账户上</li><li>之后需要配置本地博客网站的部署配置，依然是在_config.yml中，在文件最下方找到deploy字段如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type:</span><br></pre></td></tr></table></figure>在type字段中填写 git<br>之后在下一行新增一个字段 repo，填入你刚刚创建的git仓库地址，应该是如下形式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https:&#x2F;&#x2F;github.com&#x2F;xxxx&#x2F;xxx.github.io.git</span><br></pre></td></tr></table></figure>repo字段根据选择的不同协议，可以选择https或者ssh认证</li></ul><p>一切都配置完毕后，我们就可以将网站部署到github page上去了！<br><code>hexo deploy</code><br>可以简写为 <code>hexo d</code><br>首次部署需要进行身份验证，如果采用https协议，需要输入github账号密码。如果采用ssh协议则不需要。</p><p>如果没有提示什么错误，稍等片刻，我们在浏览器输入与刚刚创建好的仓库的同名域名 xxx.github.io 即可以看到我们创建好的个人网站了！</p><h3 id="个性化域名"><a href="#个性化域名" class="headerlink" title="个性化域名"></a>个性化域名</h3><p>如果想要为自己的网站设置一个个性化的域名，那么我们需要向域名供应商购买一个域名并且配置相应的dns服务，更多内容可以自行查阅，本文不再过多阐述。</p><h3 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h3><p><a href="https://hexo.io/zh-cn/docs/front-matter" target="_blank" rel="noopener">hexo官方文档</a><br><a href="https://pages.github.com/" target="_blank" rel="noopener">github pages官方指南</a><br><a href="https://www.jianshu.com/p/191d1e21f7ed" target="_blank" rel="noopener">markdown语法简介</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;为什么要写博客&quot;&gt;&lt;a href=&quot;#为什么要写博客&quot; class=&quot;headerlink&quot; title=&quot;为什么要写博客&quot;&gt;&lt;/a&gt;为什么要写博客&lt;/h2&gt;&lt;p&gt;一直以来都有想写博客的想法，但一方面又觉得自己没有什么技术积累，言之无物，另一方面又担心没
      
    
    </summary>
    
      <category term="环境搭建" scheme="https://njuwuyuxin.github.io/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="hexo" scheme="https://njuwuyuxin.github.io/tags/hexo/"/>
    
      <category term="node" scheme="https://njuwuyuxin.github.io/tags/node/"/>
    
      <category term="指南" scheme="https://njuwuyuxin.github.io/tags/%E6%8C%87%E5%8D%97/"/>
    
  </entry>
  
</feed>
